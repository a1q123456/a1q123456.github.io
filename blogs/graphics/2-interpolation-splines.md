---
title:  "Interpolation in Graphics World"
subtitle: "Part 2 Splines"
date:   2023-02-22 00:00:00
---

In the last article, we discussed polynomial interpolation. It works, but we will struggle to find coefficients for big data sets. Instead of using polynomial interpolation, we can use splines to solve this issue. 

Splines define multiple pieces of a curve and keep the curve smooth by ensuring the tangent of each point on the curve is continuous. Therefore, it does not need to increase the degree when we add more values to interpolate. This article is going to discuss some commonly used splines.

# B-Spline Curves

The form of the B-Spline is defined recursively.

$$
S_{n,t}(x) := \sum_{i} a_iB_{i,n}(x)
$$

Where $n$ is the degree of the spline; $t$ is knots; $a$ is control points; $B$ is the B-spline basis function, defined by:

$$
B_{i,0} := 
\begin{cases}
1 & \text{if } t_i \leq x \leq t_{i+1} \\
0 & \text{otherwise}
\end{cases}
$$

$$
B_{i,n}(x) := 
\frac{x-t_i} {t_{i+n} - t_i} B_{i,n-1}(x) + 
\frac{t_{i+n+1}-x} {t_{i+n+1}-t_{i+1}} B_{i+1, n-1}(x)
$$

It is possible that $t_{i+n} - t_i = 0$ or $t_{i+n+1} - t_{i+1} = 0$, which generates an $\inf$ result. In this case, we should prevent $\inf$ from being generated and treat the whole term as zero instead.

The above equations can be simplified to the following Matlab functions:
```c
function y = basis_spline(t, i, k, x)
    if k == 0
        if t(i) <= x && x < t(i + 1)
            y = 1;
        else
            y = 0;
        end
        return;
    end

    if t(i) == t(i+k)
        a = 0;
    else
        a = ((x - t(i)) / (t(i+k)-t(i))) * basis_spline(t, i, k-1, x);
    end
    if t(i+k+1) == t(i+1)
        b = 0;
    else
        b = ((t(i+k+1)-x)/(t(i+k+1)-t(i+1))) * basis_spline(t, i+1, k-1, x);
    end
    y = a + b;
end

function y = b_spline_curve(t, k, a, x)
    y = 0;
    for i = 1:length(a)
        y = y + a(i) * basis_spline(t, i, k, x);
    end
end
```

If use the `b_spline_curve` to interpolate a data set `[10, 30, 40, 0, 10, 15, 0]` and a knots vector `[0, 1, 2, 3, 4]`, we will get the following result:

![Polynomial](/images/2-interpolation-splines.md/bspline.jpg)

We may give the knot vector a different value, for example,  `[0, 1, 3, 4, 5]`. In this case, it yields a non-uniform curve, as the difference of each value in the knot vector is different.

# NURBS

In the above case, the difference between each knot is the same, which generates a *uniform* B-Spline. 

*NURBS* is the abbreviation of *Non-uniform rational B-spline*. It generates a smooth result and is commonly used in computer graphics, CAD, and manufacturing.

With NURBS, we may define the weight of each control point, which affects how much a control point affects the curve.

A NURBS is defined by:

$$
S_{n,t}(x) := \sum_{i} a_i\frac {B_{i,n}(x)w_i} {\sum_{j} B_{j,n}(x)w_i }
$$

Where $w$ is the weight vector.

The above equation can be written in Matlab:
```c
function y = nurbs(t, k, a, w, x)
    y = 0;

    for i = 1:length(a)
        b = 0;
        for j = 1:length(a)
            b = b + basis_spline(t, j, k, x) * w(j);
        end
        r = (basis_spline(t, i, k, x) * w(i)) / b;
        y = y + a(i) * r;
    end
end
```

![NURBS](/images/2-interpolation-splines.md/nurbs.jpg)

The above figure was generated by the `nurbs` function with weights `[1, 1, 1, 5, 1, 1, 1]`.

# Bézier curves

The bézier curve is also commonly used, which may contain sharp corners. 

A cubic bézier curve is defined by:

$$
B(x) = (1-x)^3P_0+3(1-x)^2xP_1+3(1-x)x^2P_2+x^3P_3 \text{, } 0 \le x \le 1
$$

Where $P_1$ and $P_2$ are usually treated as the tangent of $P_0$ and $P_3$.

![Bézier](/images/2-interpolation-splines.md/bezier.jpg)

The above figure is generated by the following Matlab function. There is a sharp corner on $x = 3$ because point 2, point 3 and point 4 are not on the same line. In this case, point 3 has two tangent lines, which causes the sharp corner.

```c
function y = cubic_bezier_curve(a, x)
    y = (1 - x).^3 * a(1) + 3 * (1 - x).^2 .* x * a(2) + 3 * (1 - x) .* x.^2 * a(3) + x.^3 * a(4);
end
```

# Hermite Spline Curves

The Hermite spline can be defined as:
$$
H(x) = (2x^3 - 3x^2 + 1)p_1 + (3x^2-2x^3)p_2 + (x^3 - 2x^2 + x)m_1 + (x^3 - x^2)m_2
$$

Where $p_1$ and $p_2$ are the control points, $m_1$ and $m_2$ are tangents. It becomes a **canonical spline** if we calculate the tangents by using the following formula:
$$
m_k = (1 - C) \frac{p_{k+1} - p_{k-1}} {2}
$$

Where $C$ is a smooth parameter. $C=0.5$ generates a **Catmull–Rom spline**, which is commonly used for keyframe interpolation.

The above equations can be rewritten to the following Matlab function:
```c
function y = hermite_spline_curve(C, a, x)
    m1 = (1 - C) * (a(3:end-1) - a(1:end-3)) / 2;
    m2 = (1 - C) * (a(4:end) - a(2:end-2)) / 2;
    
    p1 = a(2:end-2);
    p2 = a(3:end-1);

    x = x';
    y = (2 * x.^3 - 3 * x.^2 + 1) .* p1 + (-2 * x.^3 + 3 * x.^2) .* p2 + (x.^3 - 2 * x.^2 + x) .* m1 + (x.^3 - x.^2) .* m2;
    d = y(1:end-1,1:end-1);
    y = [d(:)' y(1:end,end)'];
end
```

The following figure is generated based on $C=0.5$:

![Catmull–Rom](/images/2-interpolation-splines.md/catmullrom.jpg)

My [SWRenderer](https://github.com/a1q123456/SWRenderer) project uses the Hermite spline and the cubic convolution to interpolate texture data. We will discuss cubic convolution in the following article.
